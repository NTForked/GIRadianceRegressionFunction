#include "neuralnetworkloader.h"
#include "neuralnetwork.h"

#include <iostream>
#include <string>

NeuralNetworkLoader::NeuralNetworkLoader()
{
}

/*
 * Load NeuralNetwork from a XML file
 * The format of the XML input file is the format of
 * files generated by OpenNN (see OpenNNdocumentation)
 *
 * This code is taken from OpenNN and modified to match to
 * our structures
 * */
void NeuralNetworkLoader::loadFile(const std::string &file_name, NeuralNetwork &neural_network)
{
    tinyxml2::XMLDocument document;

    if(document.LoadFile(file_name.c_str()))
        errorHandler("NEURALNETWORKLOADER::LOADFILE::ERROR Can't load file");

    const tinyxml2::XMLElement* root_element = document.FirstChildElement("NeuralNetwork");

    if(!root_element)
        errorHandler("NEURALNETWORKLOADER::LOADFILE::ERROR Problem with node <NeuralNetwork>");

    // Scaling layer
    {
        const tinyxml2::XMLElement* element = root_element->FirstChildElement("ScalingLayer");

        if(element)
        {
            tinyxml2::XMLDocument scaling_layer_document;
            tinyxml2::XMLElement* element_clone = scaling_layer_document.NewElement("ScalingLayer");
            scaling_layer_document.InsertFirstChild(element_clone);
            DeepClone(element_clone, element, &scaling_layer_document, NULL);

            ScalingLayerFromXML(scaling_layer_document, neural_network.scaling_layer);
        }
    }

    // Multilayer perceptron
    {
        const tinyxml2::XMLElement* element = root_element->FirstChildElement("MultilayerPerceptron");

        if(element)
        {
            tinyxml2::XMLDocument multilayer_perceptron_document;
            tinyxml2::XMLElement* element_clone = multilayer_perceptron_document.NewElement("MultilayerPerceptron");
            multilayer_perceptron_document.InsertFirstChild(element_clone);
            DeepClone(element_clone, element, &multilayer_perceptron_document, NULL);

            MultilayerPerceptronFromXML(multilayer_perceptron_document, neural_network.multilayer_perceptron);
        }
    }

    // Unscaling layer
    {
        const tinyxml2::XMLElement* element = root_element->FirstChildElement("UnscalingLayer");

        if(element)
        {
            tinyxml2::XMLDocument unscaling_layer_document;

            tinyxml2::XMLElement* element_clone = unscaling_layer_document.NewElement("UnscalingLayer");
            unscaling_layer_document.InsertFirstChild(element_clone);

            DeepClone(element_clone, element, &unscaling_layer_document, NULL);

            UnscalingLayerFromXML(unscaling_layer_document, neural_network.unscaling_layer);
        }
    }
}

//  SCALING LAYER
void NeuralNetworkLoader::ScalingLayerFromXML(const tinyxml2::XMLDocument& document, ScalingLayer &scaling_layer)
{
    const tinyxml2::XMLElement* scaling_layer_element = document.FirstChildElement("ScalingLayer");
    if(!scaling_layer_element)
        errorHandler("NEURALNETWORKLOADER::SCALINGLAYERFROMXML::ERROR Problem with node <ScalingLayer>");

    const tinyxml2::XMLElement* scaling_neurons_number_element = scaling_layer_element->FirstChildElement("ScalingNeuronsNumber");
    if(!scaling_neurons_number_element)
        errorHandler("NEURALNETWORKLOADER::SCALINGLAYERFROMXML::ERROR Problem with node <ScalingNeuronsNumber>");

    scaling_layer.statistics_size = atoi(scaling_neurons_number_element->GetText());
    scaling_layer.statistics = new Statistics[scaling_layer.statistics_size];

    unsigned index = 0; // size_t does not work
    const tinyxml2::XMLElement* start_element = scaling_neurons_number_element;

    for(size_t i = 0; i < scaling_layer.statistics_size; ++i)
    {
        const tinyxml2::XMLElement* statistics_element = start_element->NextSiblingElement("Statistics");
        start_element = statistics_element;

        if(!statistics_element)
            errorHandler("NEURALNETWORKLOADER::SCALINGLAYERFROMXML::ERROR Problem with node <Statistics>");

        statistics_element->QueryUnsignedAttribute("Index", &index);
        if(index != i+1)
            errorHandler("NEURALNETWORKLOADER::SCALINGLAYERFROMXML::ERROR Problem with node <Index>");

        // Minimum
        const tinyxml2::XMLElement* minimum_element = statistics_element->FirstChildElement("Minimum");
        if(!minimum_element)
            errorHandler("NEURALNETWORKLOADER::SCALINGLAYERFROMXML::ERROR Problem with node <Minimum>");
        else if(minimum_element->GetText())
            scaling_layer.statistics[i].minimum = atof(minimum_element->GetText());

        // Maximum
        const tinyxml2::XMLElement* maximum_element = statistics_element->FirstChildElement("Maximum");
        if(!maximum_element)
            errorHandler("NEURALNETWORKLOADER::SCALINGLAYERFROMXML::ERROR Problem with node <Maximum>");
        else if(maximum_element->GetText())
            scaling_layer.statistics[i].maximum = atof(maximum_element->GetText());

        // Mean
        const tinyxml2::XMLElement* mean_element = statistics_element->FirstChildElement("Mean");
        if(!mean_element)
            errorHandler("NEURALNETWORKLOADER::SCALINGLAYERFROMXML::ERROR Problem with node <Mean>");
        else if(mean_element->GetText())
            scaling_layer.statistics[i].mean = atof(mean_element->GetText());

        // Standard deviation
        const tinyxml2::XMLElement* standard_deviation_element = statistics_element->FirstChildElement("StandardDeviation");
        if(!standard_deviation_element)
            errorHandler("NEURALNETWORKLOADER::SCALINGLAYERFROMXML::ERROR Problem with node <StandardDeviation>");
        else if(standard_deviation_element->GetText())
            scaling_layer.statistics[i].standard_deviation = atof(standard_deviation_element->GetText());
    }

    // Scaling method
    {
        const tinyxml2::XMLElement* scaling_method_element = scaling_layer_element->FirstChildElement("ScalingMethod");
        if(scaling_method_element)
        {
            std::string new_method = scaling_method_element->GetText();
            if(new_method == "NoScaling")
                scaling_layer.scaling_method = NoScaling;
            else if(new_method == "MinimumMaximum")
                scaling_layer.scaling_method = MinimumMaximum;
            else if(new_method == "MeanStandardDeviation")
                scaling_layer.scaling_method = MeanStandardDeviation;
        }
    }
}

//  MULTILAYERPERCEPTRON
void NeuralNetworkLoader::MultilayerPerceptronFromXML(const tinyxml2::XMLDocument& document, MultilayerPerceptron &multilayer_perceptron)
{
    const tinyxml2::XMLElement* root_element = document.FirstChildElement("MultilayerPerceptron");
    if(!root_element)
        errorHandler("NEURALNETWORKLOADER::SCALINGLAYERFROMXML::ERROR Problem with node <MultilayerPerceptron>");

    // Architecture
    {
        const tinyxml2::XMLElement* architecture_element = root_element->FirstChildElement("Architecture");

        if(architecture_element)
        {
            const char* architecture_text = architecture_element->GetText();

            if(architecture_text)
            {
                std::vector<std::string> architecture_split = splitValues(architecture_text);

                multilayer_perceptron.layers_size = architecture_split.size() - 1;
                multilayer_perceptron.perceptron_layers = new PerceptronLayer[multilayer_perceptron.layers_size];
                for(unsigned int i = 0; i < multilayer_perceptron.layers_size; ++i)
                {
                    multilayer_perceptron.perceptron_layers[i].perceptrons_size = std::stoi(architecture_split[i + 1]);
                    multilayer_perceptron.perceptron_layers[i].perceptrons = new Perceptron[multilayer_perceptron.perceptron_layers[i].perceptrons_size];

                    for(unsigned int j = 0; j < multilayer_perceptron.perceptron_layers[i].perceptrons_size; ++j)
                    {
                        multilayer_perceptron.perceptron_layers[i].perceptrons[j].inputs_number = std::stoi(architecture_split[i]);
                        multilayer_perceptron.perceptron_layers[i].perceptrons[j].synaptic_weights = new float[multilayer_perceptron.perceptron_layers[i].perceptrons[j].inputs_number];
                    }
                }
            }
        }
    }

    // Layers activation function
    {
        const tinyxml2::XMLElement* layers_activation_function_element = root_element->FirstChildElement("LayersActivationFunction");

        if(layers_activation_function_element)
        {
            const char* layers_activation_function_text = layers_activation_function_element->GetText();

            if(layers_activation_function_text)
            {
                std::vector<std::string> new_layers_activation_function = splitValues(layers_activation_function_text);

                for(size_t i = 0; i < multilayer_perceptron.layers_size; ++i)
                {
                    unsigned int activation_function;

                    if(new_layers_activation_function[i] == "Linear")
                        activation_function = Linear;
                    else if(new_layers_activation_function[i] == "HyperbolicTangent")
                        activation_function = HyperbolicTangent;

                    for(size_t j = 0; j < multilayer_perceptron.perceptron_layers[i].perceptrons_size; ++j)
                        multilayer_perceptron.perceptron_layers[i].perceptrons[j].activation_function = activation_function;
                }
            }
        }
    }

    // Parameters
    {
        const tinyxml2::XMLElement* parameters_element = root_element->FirstChildElement("Parameters");

        if(parameters_element)
        {
            const char* parameters_text = parameters_element->GetText();

            if(parameters_text)
            {
                std::vector<std::string> new_parameters_text = splitValues(parameters_text);

                unsigned int parameters_index = 0;
                for(size_t i = 0; i < multilayer_perceptron.layers_size; ++i)
                {
                    for(unsigned int j = 0; j < multilayer_perceptron.perceptron_layers[i].perceptrons_size; ++j)
                    {
                        multilayer_perceptron.perceptron_layers[i].perceptrons[j].bias = std::stof(new_parameters_text[parameters_index++]);
                        for(unsigned int k = 0; k < multilayer_perceptron.perceptron_layers[i].perceptrons[j].inputs_number; ++k)
                            multilayer_perceptron.perceptron_layers[i].perceptrons[j].synaptic_weights[k] = std::stof(new_parameters_text[parameters_index++]);
                    }
                }
            }
        }
    }
}

//  UNSCALING LAYER
void NeuralNetworkLoader::UnscalingLayerFromXML(const tinyxml2::XMLDocument& document, UnscalingLayer &unscaling_layer)
{
    const tinyxml2::XMLElement* unscaling_layer_element = document.FirstChildElement("UnscalingLayer");
    if(!unscaling_layer_element)
        errorHandler("NEURALNETWORKLOADER::UNSCALINGLAYER::ERROR Problem with node <UnscalingLayer>");

    const tinyxml2::XMLElement* unscaling_neurons_number_element = unscaling_layer_element->FirstChildElement("UnscalingNeuronsNumber");
    if(!unscaling_neurons_number_element)
        errorHandler("NEURALNETWORKLOADER::UNSCALINGLAYER::ERROR Problem with node <UnscalingNeuronsNumber>");

    unscaling_layer.statistics_size = atoi(unscaling_neurons_number_element->GetText());
    unscaling_layer.statistics = new Statistics[unscaling_layer.statistics_size];

    unsigned index = 0; // size_t does not work
    const tinyxml2::XMLElement* start_element = unscaling_neurons_number_element;

    for(size_t i = 0; i < unscaling_layer.statistics_size; ++i)
    {
        const tinyxml2::XMLElement* statistics_element = start_element->NextSiblingElement("Statistics");
        start_element = statistics_element;
        if(!statistics_element)
            errorHandler("NEURALNETWORKLOADER::UNSCALINGLAYER::ERROR Problem with node <Statistics>");

        statistics_element->QueryUnsignedAttribute("Index", &index);
        if(index != i+1)
            errorHandler("NEURALNETWORKLOADER::UNSCALINGLAYER::ERROR Problem with node <Index>");

        // Minimum
        const tinyxml2::XMLElement* minimum_element = statistics_element->FirstChildElement("Minimum");
        if(!minimum_element)
            errorHandler("NEURALNETWORKLOADER::UNSCALINGLAYER::ERROR Problem with node <Minimum>");
        else if(minimum_element->GetText())
            unscaling_layer.statistics[i].minimum = atof(minimum_element->GetText());

        // Maximum
        const tinyxml2::XMLElement* maximum_element = statistics_element->FirstChildElement("Maximum");
        if(!maximum_element)
            errorHandler("NEURALNETWORKLOADER::UNSCALINGLAYER::ERROR Problem with node <Maximum>");
        else if(maximum_element->GetText())
            unscaling_layer.statistics[i].maximum = atof(maximum_element->GetText());

        // Mean
        const tinyxml2::XMLElement* mean_element = statistics_element->FirstChildElement("Mean");
        if(!mean_element)
            errorHandler("NEURALNETWORKLOADER::UNSCALINGLAYER::ERROR Problem with node <Mean>");
        else if(mean_element->GetText())
            unscaling_layer.statistics[i].mean = atof(mean_element->GetText());

        // Standard deviation
        const tinyxml2::XMLElement* standard_deviation_element = statistics_element->FirstChildElement("StandardDeviation");
        if(!standard_deviation_element)
            errorHandler("NEURALNETWORKLOADER::UNSCALINGLAYER::ERROR Problem with node <StandardDeviation>");
        else if(standard_deviation_element->GetText())
            unscaling_layer.statistics[i].standard_deviation = atof(standard_deviation_element->GetText());
    }

    // Unscaling method
    {
        const tinyxml2::XMLElement *unscaling_method_element = unscaling_layer_element->FirstChildElement("UnscalingMethod");
        if(unscaling_method_element)
        {
            std::string new_method = unscaling_method_element->GetText();
            if(new_method =="NoScaling")
                unscaling_layer.unscaling_method = NoScaling;
            else if(new_method == "MinimumMaximum")
                unscaling_layer.unscaling_method = MinimumMaximum;
            else if(new_method == "MeanStandardDeviation")
                unscaling_layer.unscaling_method = MeanStandardDeviation;
        }
    }
}

bool NeuralNetworkLoader::errorHandler(const char *msg) const
{

    std::cerr << msg << std::endl;
    return false;
}

/*
 * Split a char* of values separated by ' '
 * return a string vector of the values
 * */
std::vector<std::string> NeuralNetworkLoader::splitValues(const char *values) const
{
    std::vector<std::string> out;

    std::string values_string = values;
    char delimiter = ' ';

    size_t pos = 0;
    std::string token;
    while((pos = values_string.find(delimiter)) != std::string::npos)
    {
        token = values_string.substr(0, pos);
        out.push_back(token);
        values_string.erase(0, pos + 1);
    }
    out.push_back(values_string);

    return out;
}
