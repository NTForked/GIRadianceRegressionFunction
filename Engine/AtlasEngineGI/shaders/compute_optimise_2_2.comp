#version 430 compatibility
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_compute_storage_buffer_shader : enable

// Scaling Methods
#define NoScaling 0
#define Minimummaximum 1
#define MeanStandardDeviation 2

// Activation Functions
#define Linear 0
#define HyperbolicTangent 1

#define MAX_INPUTS_SIZE 12
#define MAX_STATISTICS_SIZE 20
#define MAX_OUTPUTS_SIZE 3

// Structures
/**************************************************************************************************************************************/
struct Perceptron
{
	uint inputs_number;

	int activation_function;
	float bias;
	float synaptic_weights[MAX_STATISTICS_SIZE];
};

struct PerceptronLayer
{
	uint perceptrons_size;

	Perceptron perceptrons[MAX_STATISTICS_SIZE];
};

struct MultilayerPerceptron
{
	int layers_size;

	PerceptronLayer perceptron_layers[MAX_STATISTICS_SIZE];
};

struct Statistics
{
	float minimum;
	float maximum;
	float mean;
	float standard_deviation;
};

struct ScalingLayer
{
	uint statistics_size;

	int scaling_method;
	Statistics statistics[MAX_STATISTICS_SIZE];
};

struct UnscalingLayer
{
	uint statistics_size;

	int scaling_method;
	Statistics statistics[MAX_STATISTICS_SIZE];
};
/**************************************************************************************************************************************/

// Scaling Layer
float[MAX_STATISTICS_SIZE] ScalingLayerCalculateOutputs(float inputs[MAX_INPUTS_SIZE], ScalingLayer scaling_layer)
{
	float outputs[MAX_STATISTICS_SIZE];

	for (uint i = 0; i < MAX_INPUTS_SIZE /*scaling_layer.statistics_size*/; ++i)
	{
    outputs[i] = inputs[i];
		if ((scaling_layer.statistics[i].maximum - scaling_layer.statistics[i].minimum) >= 1e-99)
		{
			outputs[i] = 2.0 * (inputs[i] - scaling_layer.statistics[i].minimum * (1.0 / (scaling_layer.statistics[i].maximum - scaling_layer.statistics[i].minimum)) - 1.0);
		}
	}

	return outputs;
}

// Combination
/**************************************************************************************************************************************/
float PerceptronLayerCalculateCombination(float inputs[MAX_STATISTICS_SIZE], Perceptron perceptron, uint inputs_number)
{
	float combination = perceptron.bias;

	for (uint i = 0; i < inputs_number; ++i)
	{
		combination += perceptron.synaptic_weights[i] * inputs[i];
	}
	return combination;
}



float[MAX_STATISTICS_SIZE] PerceptronLayerCalculateCombinations(float inputs[MAX_STATISTICS_SIZE], PerceptronLayer perceptron_layer, uint nb_perceptrons, uint inputs_number)
{
	float combination[MAX_STATISTICS_SIZE];

	for (uint i = 0; i < nb_perceptrons /*perceptron_layer.perceptrons_size*/; ++i)
	{
		combination[i] = PerceptronLayerCalculateCombination(inputs, perceptron_layer.perceptrons[i], inputs_number);
	}
	return combination;
}
/**************************************************************************************************************************************/


// Activation
/**************************************************************************************************************************************/
float[MAX_STATISTICS_SIZE] PerceptronLayerCalculateActivationsHyperbolicTangent(float combinations[MAX_STATISTICS_SIZE], uint nb_perceptrons)
{
	float activations[MAX_STATISTICS_SIZE];

    for (uint i = 0; i < nb_perceptrons /*perceptron_layer.perceptrons_size*/; ++i)
	{
		activations[i] =  (1.0 - 2.0 / (exp(float(2.0 * combinations[i])) + 1.0));
    }
    return activations;
}

float[MAX_STATISTICS_SIZE] PerceptronLayerCalculateActivationsLinear(float combinations[MAX_STATISTICS_SIZE], uint nb_perceptrons)
{
	float activations[MAX_STATISTICS_SIZE];

    for (uint i = 0; i < nb_perceptrons /*perceptron_layer.perceptrons_size*/; ++i)
	  {
		  activations[i] = combinations[i];
    }
    return activations;
}
/**************************************************************************************************************************************/

// Multilayer Perceptron
float[MAX_STATISTICS_SIZE] MultilayerPerceptronCalculateOutputs(float inputs[MAX_STATISTICS_SIZE], MultilayerPerceptron multilayer_perceptron)
{
	float outputs[MAX_STATISTICS_SIZE];

    uint architecture[4];
    architecture[0] = 12;
    architecture[1] = 20;
    architecture[2] = 10;
    architecture[3] = 3;

	PerceptronLayerCalculateActivationsHyperbolicTangent(PerceptronLayerCalculateCombinations(inputs, multilayer_perceptron.perceptron_layers[0], architecture[1], architecture[0]), architecture[1]);
    outputs = PerceptronLayerCalculateActivationsHyperbolicTangent(PerceptronLayerCalculateCombinations(outputs, multilayer_perceptron.perceptron_layers[1], architecture[2], architecture[1]), architecture[2]);
    outputs = PerceptronLayerCalculateActivationsLinear(PerceptronLayerCalculateCombinations(outputs, multilayer_perceptron.perceptron_layers[2], architecture[3], architecture[2]), architecture[3]);

	return outputs;
}

// Unscaling Layer
float[MAX_STATISTICS_SIZE] UnscalingLayerCalculateOutputs(float inputs[MAX_STATISTICS_SIZE], UnscalingLayer unscaling_layer)
{
	float outputs[MAX_STATISTICS_SIZE];
	for (uint i = 0; i < MAX_OUTPUTS_SIZE /*unscaling_layer.statistics_size*/; ++i)
	{
    outputs[i] = inputs[i];
    
		if ((unscaling_layer.statistics[i].maximum - unscaling_layer.statistics[i].minimum) >= 1e-99)
    {
			outputs[i] = 0.5 * (inputs[i] + 1.0) * (unscaling_layer.statistics[i].maximum - unscaling_layer.statistics[i].minimum) + unscaling_layer.statistics[i].minimum;
		}
	}
	return outputs;
}

layout(local_size_x = 16, local_size_y = 16) in;

/*
 * Inputs
 * */
uniform vec3 camera_position;
uniform vec3 point_light_position;
uniform sampler2D gPositionDepth;
uniform sampler2D gNormal;

struct NeuralNetwork
{
	  ScalingLayer scaling_layer;
	  MultilayerPerceptron multilayer_perceptron;
	  UnscalingLayer unscaling_layer;
};

// NeuralNetwork (SSBO)
layout(std430, binding=4) buffer nn
{
	  NeuralNetwork neural_network;
};

// Output
layout(rgba32f, binding = 0) uniform image2D img_output;

void main()
{
	ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);

	ivec2 dims = imageSize(img_output); // fetch image dimensions
	float x = (float(pixel_coords.x ) * (1.0 / dims.x));
	float y = (float(pixel_coords.y ) * (1.0 / dims.y));

	vec2 texCoords = vec2(x,y);

	float inputs[12];
	// frag pos, camera, position light, normal


	inputs[0] = texture(gPositionDepth, texCoords).r;
	inputs[1] = texture(gPositionDepth, texCoords).g;
	inputs[2] = texture(gPositionDepth, texCoords).b;
	inputs[3] = camera_position.x;
	inputs[4] = camera_position.y;
	inputs[5] = camera_position.z;
	inputs[6] = point_light_position.x;
	inputs[7] = point_light_position.y;
	inputs[8] = point_light_position.z;
	inputs[9] = texture(gNormal, texCoords).r;
	inputs[10] = texture(gNormal, texCoords).g;
	inputs[11] = texture(gNormal, texCoords).b;

	/*inputs[0] = 1.0;
	inputs[1] = 1.0;
	inputs[2] = 1.0;
	inputs[3] = 1.0;
	inputs[4] = 1.0;
	inputs[5] = 1.0;
	inputs[6] = 1.0;
	inputs[7] = 1.0;
	inputs[8] = 1.0;
	inputs[9] = 1.0;
	inputs[10] = 1.0;
	inputs[11] = 1.0;*/

	float outputs_scaling[MAX_STATISTICS_SIZE];
	float outputs_multilayer[MAX_STATISTICS_SIZE];

	outputs_scaling = ScalingLayerCalculateOutputs(inputs, neural_network.scaling_layer);
    outputs_multilayer = MultilayerPerceptronCalculateOutputs(outputs_scaling, neural_network.multilayer_perceptron);
    outputs_scaling = UnscalingLayerCalculateOutputs(outputs_multilayer, neural_network.unscaling_layer);

	// output to a secific pixel in the image
    vec4 pixel = vec4(outputs_multilayer[0], outputs_multilayer[1], outputs_multilayer[2], 1.0);
	//vec4 pixel = vec4(outputs_scaling[0], outputs_scaling[1], outputs_scaling[2], 1.0);


	imageStore (img_output, pixel_coords, pixel);

}
